        TRANSLATED	ActorDefinition	Name should be usable as an identifier for the module by machine processing applications such as code generation	name.exists() implies name.matches('[A-Z]([A-Za-z0-9_]){1,254}')	{fhir:name . SHEX_Implies_SHEX {fhir:name { fhir:v /'[A-Z]([A-Za-z0-9_]){1,254}'/ } }}
        TRANSLATED	ActorDefinition.url	URL should not contain | or # - these characters make processing canonical references problematic	url.matches('([^|#])*')	{fhir:url { fhir:v /'([^|#])*'/ } }
        TRANSLATED	Age	There SHALL be a code if there is a value and it SHALL be an expression of time.  If system is present, it SHALL be UCUM.  If value is present, it SHALL be positive.	(code.exists() or value.empty()) and (system.empty() or system = %ucum) and (value.empty() or value.hasValue().not() or value > 0)	({fhir:code . OR  NOT { fhir:value {fhir:v .} } }) AND ( NOT { fhir:system {fhir:v .} }  OR ({ fhir:system { fhir:v ['http://unitsofmeasure.org'] }  })) AND ( NOT { fhir:value {fhir:v .} }  OR  NOT { fhir:value. } OR ({ fhir:value { fhir:v MinExclusive 0 }  }))
        TRANSLATED	Appointment	An appointment may have an originatingAppointment or recurrenceTemplate, but not both	originatingAppointment.exists().not() or recurrenceTemplate.exists().not()	 NOT { fhir:originatingAppointment. } OR  NOT { fhir:recurrenceTemplate. }
        TRANSLATED	Appointment	Cancellation reason is only used for appointments that have been cancelled, or noshow	cancellationReason.exists() implies (status='noshow' or status='cancelled')	{fhir:cancellationReason . SHEX_Implies_SHEX (({ fhir:status { fhir:v ['noshow'] }  }) OR ({ fhir:status { fhir:v ['cancelled'] }  }))}
        TRANSLATED	Appointment	Either start and end are specified, or neither	start.exists() = end.exists()	{fhir:start . SHEX_Equals_SHEX {fhir:end .}}
        TRANSLATED	Appointment	Only proposed or cancelled appointments can be missing start/end dates	(start.exists() and end.exists()) or (status in ('proposed' | 'cancelled' | 'waitlist'))	({fhir:start . AND {fhir:end .}}) OR ({ fhir:status { fhir:v ['proposed' 'cancelled' 'waitlist'] }  })
        TRANSLATED	Appointment	The start must be less than or equal to the end	start.exists() implies start <= end	{fhir:start . SHEX_Implies_SHEX ({ fhir:start SHEX_LessOrEqual_SHEX { fhir:end } })}
        TRANSLATED	Appointment.participant	Either the type or actor on the participant SHALL be specified	type.exists() or actor.exists()	{fhir:type . OR {fhir:actor .}}
        TRANSLATED	AppointmentResponse	Either the participantType or actor must be specified	participantType.exists() or actor.exists()	{fhir:participantType . OR {fhir:actor .}}
        TRANSLATED	Attachment	If the Attachment has data, it SHALL have a contentType	data.empty() or contentType.exists()	 NOT { fhir:data {fhir:v .} }  OR {fhir:contentType .}
        TRANSLATED	Availability.availableTime	Cannot include start/end times when selecting all day availability.	allDay.exists().not() or (allDay implies availableStartTime.exists().not() and availableEndTime.exists().not())	 NOT { fhir:allDay. } OR ({ fhir:allDay SHEX_Implies_SHEX ( NOT { fhir:availableStartTime. } AND  NOT { fhir:availableEndTime. }) })
        TRANSLATED	BackboneElement.modifierExtension	All FHIR elements must have a @value or children	hasValue() or (children().count() > id.count())	 . OR (  SHEX_count_SHEX (   SHEX_children_SHEX (  ) ) SHEX_Greater_SHEX   SHEX_count_SHEX ( fhir:id ))
        TRANSLATED	BackboneElement.modifierExtension	Must have either extensions or value[x], not both	extension.exists() != value.exists()	{fhir:extension . SHEX_NotEquals_SHEX {fhir:value .}}
        TRANSLATED	Bundle	A document must have a Composition as the first resource	type = 'document' implies entry.first().resource.is(Composition)	({ fhir:type { fhir:v ['document'] }  }) SHEX_Implies_SHEX   SHEX_first_SHEX ( fhir:entry ).resource { a [Composition] } 
        TRANSLATED	Bundle	A document must have a date	type = 'document' implies (timestamp.hasValue())	({ fhir:type { fhir:v ['document'] }  }) SHEX_Implies_SHEX ({fhir:timestamp .})
        TRANSLATED	Bundle	A document must have an identifier with a system and a value	type = 'document' implies (identifier.system.exists() and identifier.value.exists())	({ fhir:type { fhir:v ['document'] }  }) SHEX_Implies_SHEX ({fhir:identifier.system . AND {fhir:identifier.value .}})
        TRANSLATED	Bundle	A message must have a MessageHeader as the first resource	type = 'message' implies entry.first().resource.is(MessageHeader)	({ fhir:type { fhir:v ['message'] }  }) SHEX_Implies_SHEX   SHEX_first_SHEX ( fhir:entry ).resource { a [MessageHeader] } 
        TRANSLATED	Bundle	A subscription-notification must have a SubscriptionStatus as the first resource	type = 'subscription-notification' implies entry.first().resource.is(SubscriptionStatus)	({ fhir:type { fhir:v ['subscription-notification'] }  }) SHEX_Implies_SHEX   SHEX_first_SHEX ( fhir:entry ).resource { a [SubscriptionStatus] } 
        TRANSLATED	Bundle	Bundle resources where type is not transaction, transaction-response, batch, or batch-response or when the request is a POST SHALL have Bundle.entry.fullUrl populated	type='transaction' or type='transaction-response' or type='batch' or type='batch-response' or entry.all(fullUrl.exists() or request.method='POST')	({ fhir:type { fhir:v ['transaction'] }  }) OR ({ fhir:type { fhir:v ['transaction-response'] }  }) OR ({ fhir:type { fhir:v ['batch'] }  }) OR ({ fhir:type { fhir:v ['batch-response'] }  }) OR {fhir:entry. SHEX_all_SHEX (fullUrl . OR request.method { fhir:v ['POST'] } )}
        TRANSLATED	Bundle	FullUrl must be unique in a bundle, or else entries with the same fullUrl must have different meta.versionId (except in history bundles)	(type = 'history') or entry.where(fullUrl.exists()).select(fullUrl&resource.meta.versionId).isDistinct()	({ fhir:type { fhir:v ['history'] }  }) OR   SHEX_isDistinct_SHEX ( fhir:entry.SHEX_where_SHEX (fullUrl .).SHEX_select_SHEX (fullUrl SHEX_Concatenate_SHEX resource.meta.versionId) )
        TRANSLATED	Bundle	Issue.severity for all issues within the OperationOutcome must be either 'information' or 'warning'.	issues.exists() implies (issues.OperationOutcome.issue.severity = 'information' or issues.OperationOutcome.issue.severity = 'warning')	{fhir:issues . SHEX_Implies_SHEX (({fhir:issues.OperationOutcome.issue.severity { fhir:v ['information'] } }) OR ({fhir:issues.OperationOutcome.issue.severity { fhir:v ['warning'] } }))}
        TRANSLATED	Bundle	Use and meaning of issues for documents has not been validated because the content will not be rendered in the document.	type = 'document' implies issues.empty()	({ fhir:type { fhir:v ['document'] }  }) SHEX_Implies_SHEX  NOT { fhir:issues {fhir:v .} } 
        TRANSLATED	Bundle	entry.request mandatory for batch/transaction/history, allowed for subscription-notification, otherwise prohibited	entry.all(request.exists() = (%resource.type = 'batch' or %resource.type = 'transaction' or %resource.type = 'history')) or (type='subscription-notification')	{fhir:entry. SHEX_all_SHEX (request . { fhir:v ['false'.type { fhir:v ['batch'] }  OR 'false'.type { fhir:v ['transaction'] }  OR 'false'.type { fhir:v ['history'] } ] } ) OR ({ fhir:type { fhir:v ['subscription-notification'] }  })}
        TRANSLATED	Bundle	entry.request.method PATCH not allowed for history	type = 'history' implies entry.request.method != 'PATCH'	({ fhir:type { fhir:v ['history'] }  }) SHEX_Implies_SHEX ({fhir:entry.request.method [fhir:v  . -'PATCH'] })
        TRANSLATED	Bundle	entry.response mandatory for batch-response/transaction-response/history, allowed for subscription-notification, otherwise prohibited	entry.all(response.exists() = (%resource.type = 'batch-response' or %resource.type = 'transaction-response' or %resource.type = 'history')) or (type='subscription-notification')	{fhir:entry. SHEX_all_SHEX (response . { fhir:v ['false'.type { fhir:v ['batch-response'] }  OR 'false'.type { fhir:v ['transaction-response'] }  OR 'false'.type { fhir:v ['history'] } ] } ) OR ({ fhir:type { fhir:v ['subscription-notification'] }  })}
        TRANSLATED	Bundle	entry.search only when a search	entry.search.empty() or (type = 'searchset')	 NOT { fhir:entry.search {fhir:v .} }  OR ({ fhir:type { fhir:v ['searchset'] }  })
        TRANSLATED	Bundle	total only when a search or history	total.empty() or (type = 'searchset') or (type = 'history')	 NOT { fhir:total {fhir:v .} }  OR ({ fhir:type { fhir:v ['searchset'] }  }) OR ({ fhir:type { fhir:v ['history'] }  })
        TRANSLATED	Bundle.entry	fullUrl cannot be a version specific reference	fullUrl.exists() implies fullUrl.contains('/_history/').not()	{fhir:fullUrl . SHEX_Implies_SHEX  NOT { fhir:fullUrl{ fhir:v ['/_history/'] } }}
        TRANSLATED	Bundle.entry	must be a resource unless there's a request or response	resource.exists() or request.exists() or response.exists()	{fhir:resource . OR {fhir:request . OR {fhir:response .}}}
        TRANSLATED	CanonicalResource	Name should be usable as an identifier for the module by machine processing applications such as code generation	name.exists() implies name.matches('[A-Z]([A-Za-z0-9_]){1,254}')	{fhir:name . SHEX_Implies_SHEX {fhir:name { fhir:v /'[A-Z]([A-Za-z0-9_]){1,254}'/ } }}
        TRANSLATED	CanonicalResource.url	URL should not contain | or # - these characters make processing canonical references problematic	url.matches('([^|#])*')	{fhir:url { fhir:v /'([^|#])*'/ } }
        TRANSLATED	CapabilityStatement	A Capability Statement SHALL have at least one of REST, messaging or document element.	rest.exists() or messaging.exists() or document.exists()	{fhir:rest . OR {fhir:messaging . OR {fhir:document .}}}
        TRANSLATED	CapabilityStatement	A Capability Statement SHALL have at least one of description, software, or implementation element.	(description.count() + software.count() + implementation.count()) > 0	(  SHEX_count_SHEX ( fhir:description ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:software ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:implementation )) { fhir:v MinExclusive 0 } 
        TRANSLATED	CapabilityStatement	If kind = capability, implementation must be absent, software must be present	(kind != 'capability') or (implementation.exists().not() and software.exists())	({ fhir:kind [fhir:v  . -'capability']  }) OR ( NOT { fhir:implementation. } AND {fhir:software .})
        TRANSLATED	CapabilityStatement	If kind = instance, implementation must be present and software may be present	(kind != 'instance') or implementation.exists()	({ fhir:kind [fhir:v  . -'instance']  }) OR {fhir:implementation .}
        TRANSLATED	CapabilityStatement	If kind = requirements, implementation and software must be absent	(kind!='requirements') or (implementation.exists().not() and software.exists().not())	({ fhir:kind [fhir:v  . -'requirements']  }) OR ( NOT { fhir:implementation. } AND  NOT { fhir:software. })
        TRANSLATED	CapabilityStatement	Messaging end-point is only permitted when a capability statement is for an implementation.	messaging.endpoint.empty() or kind = 'instance'	 NOT { fhir:messaging.endpoint {fhir:v .} }  OR ({ fhir:kind { fhir:v ['instance'] }  })
        TRANSLATED	CapabilityStatement	Name should be usable as an identifier for the module by machine processing applications such as code generation	name.exists() implies name.matches('[A-Z]([A-Za-z0-9_]){1,254}')	{fhir:name . SHEX_Implies_SHEX {fhir:name { fhir:v /'[A-Z]([A-Za-z0-9_]){1,254}'/ } }}
        TRANSLATED	CapabilityStatement	The set of documents must be unique by the combination of profile and mode.	document.select(profile&mode).isDistinct()	  SHEX_isDistinct_SHEX ( fhir:document.SHEX_select_SHEX (profile SHEX_Concatenate_SHEX mode) )
        TRANSLATED	CapabilityStatement	There should only be one CapabilityStatement.rest per mode.	rest.mode.isDistinct()	  SHEX_isDistinct_SHEX ( fhir:rest.mode )
        TRANSLATED	CapabilityStatement.rest	A given resource can only be described once per RESTful mode.	resource.select(type).isDistinct()	  SHEX_isDistinct_SHEX ( fhir:resource.SHEX_select_SHEX (type) )
        TRANSLATED	CapabilityStatement.rest.resource	Search parameter names must be unique in the context of a resource.	searchParam.select(name).isDistinct()	  SHEX_isDistinct_SHEX ( fhir:searchParam.SHEX_select_SHEX (name) )
        TRANSLATED	CapabilityStatement.url	URL should not contain | or # - these characters make processing canonical references problematic	url.matches('([^|#])*')	{fhir:url { fhir:v /'([^|#])*'/ } }
        TRANSLATED	CarePlan.activity	Cannot have both plannedActivityReference and plannedActivityDetail	plannedActivityDetail.empty() or plannedActivityReference.empty()	 NOT { fhir:plannedActivityDetail {fhir:v .} }  OR  NOT { fhir:plannedActivityReference {fhir:v .} } 
        TRANSLATED	CareTeam.participant	CareTeam.participant.onBehalfOf can only be populated when CareTeam.participant.member is a Practitioner	onBehalfOf.exists() implies (member.resolve() is Practitioner)	{fhir:onBehalfOf . SHEX_Implies_SHEX (  SHEX_resolve_SHEX ( fhir:member ) a { fhir:Practitioner })}
        TRANSLATED	CareTeam.participant	CareTeam.participant.role or CareTeam.participant.member exists	role.exists() or member.exists()	{fhir:role . OR {fhir:member .}}
        TRANSLATED	Citation	Name should be usable as an identifier for the module by machine processing applications such as code generation	name.exists() implies name.matches('[A-Z]([A-Za-z0-9_]){1,254}')	{fhir:name . SHEX_Implies_SHEX {fhir:name { fhir:v /'[A-Z]([A-Za-z0-9_]){1,254}'/ } }}
        TRANSLATED	Citation.url	URL should not contain | or # - these characters make processing canonical references problematic	url.matches('([^|#])*')	{fhir:url { fhir:v /'([^|#])*'/ } }
        TRANSLATED	CodeSystem	If a codesystem contains example, fragment, or complete content, it must have at least one concept	content in ( 'example' | 'fragment' | 'complete' ) implies concept.exists()	{ fhir:content { fhir:v ['example' 'fragment' 'complete' SHEX_Implies_SHEX {fhir:concept .}] }  }
        TRANSLATED	CodeSystem	If a codesystem contains nested concepts, it must specify hierarchyMeaning	concept.concept.exists() implies hierarchyMeaning.exists()	{fhir:concept.concept . SHEX_Implies_SHEX {fhir:hierarchyMeaning .}}
        TRANSLATED	Coding	A Coding SHOULD NOT have a display unless a code is also present.  Computation on Coding.display alone is generally unsafe.  Consider using CodeableConcept.text	code.exists().not() implies display.exists().not()	 NOT { fhir:code. } SHEX_Implies_SHEX  NOT { fhir:display. }
        TRANSLATED	Composition.section	A section can only have an emptyReason if it is empty	emptyReason.empty() or entry.empty()	 NOT { fhir:emptyReason {fhir:v .} }  OR  NOT { fhir:entry {fhir:v .} } 
        TRANSLATED	Composition.section	A section must contain at least one of text, entries, or sub-sections	text.exists() or entry.exists() or section.exists()	{fhir:text . OR {fhir:entry . OR {fhir:section .}}}
        TRANSLATED	Condition	If category is problems list item, the clinicalStatus should not be unknown	category.coding.where(system='http://terminology.hl7.org/CodeSystem/condition-category' and code='problem-list-item').exists() implies clinicalStatus.coding.where(system='http://terminology.hl7.org/CodeSystem/condition-clinical' and code='unknown').exists().not()	{fhir:category.coding. SHEX_where_SHEX (system { fhir:v ['http://terminology.hl7.org/CodeSystem/condition-category'] }  AND code { fhir:v ['problem-list-item'] } ) . SHEX_Implies_SHEX  NOT { fhir:clinicalStatus.coding.SHEX_where_SHEX (system { fhir:v ['http://terminology.hl7.org/CodeSystem/condition-clinical'] }  AND code { fhir:v ['unknown'] } ). }}
        TRANSLATED	Condition	If condition is abated, then clinicalStatus must be either inactive, resolved, or remission.	abatement.exists() implies (clinicalStatus.coding.where(system='http://terminology.hl7.org/CodeSystem/condition-clinical' and (code='inactive' or code='resolved' or code='remission')).exists())	{fhir:abatement . SHEX_Implies_SHEX ({fhir:clinicalStatus.coding. SHEX_where_SHEX (system { fhir:v ['http://terminology.hl7.org/CodeSystem/condition-clinical'] }  AND code { fhir:v ['inactive'] }  OR code { fhir:v ['resolved'] }  OR code { fhir:v ['remission'] } ) .})}
        TRANSLATED	Condition.stage	Stage SHALL have summary or assessment	summary.exists() or assessment.exists()	{fhir:summary . OR {fhir:assessment .}}
        TRANSLATED	ConditionDefinition	Name should be usable as an identifier for the module by machine processing applications such as code generation	name.exists() implies name.matches('[A-Z]([A-Za-z0-9_]){1,254}')	{fhir:name . SHEX_Implies_SHEX {fhir:name { fhir:v /'[A-Z]([A-Za-z0-9_]){1,254}'/ } }}
        TRANSLATED	ConditionDefinition.url	URL should not contain | or # - these characters make processing canonical references problematic	url.matches('([^|#])*')	{fhir:url { fhir:v /'([^|#])*'/ } }
        TRANSLATED	ContactPoint	A system is required if a value is provided.	value.empty() or system.exists()	 NOT { fhir:value {fhir:v .} }  OR {fhir:system .}
        TRANSLATED	Count	There SHALL be a code with a value of "1" if there is a value. If system is present, it SHALL be UCUM.  If present, the value SHALL be a whole number.	(code.exists() or value.empty()) and (system.empty() or system = %ucum) and (code.empty() or code = '1') and (value.empty() or value.hasValue().not() or value.toString().contains('.').not())	({fhir:code . OR  NOT { fhir:value {fhir:v .} } }) AND ( NOT { fhir:system {fhir:v .} }  OR ({ fhir:system { fhir:v ['http://unitsofmeasure.org'] }  })) AND ( NOT { fhir:code {fhir:v .} }  OR ({ fhir:code { fhir:v ['1'] }  })) AND ( NOT { fhir:value {fhir:v .} }  OR  NOT { fhir:value. } OR  NOT { fhir:value.SHEX_toString_SHEX (  ){ fhir:v ['.'] } })
        TRANSLATED	CoverageEligibilityResponse.insurance.item	SHALL contain a category or a billcode but not both.	category.exists() xor productOrService.exists()	{fhir:category . SHEX_Xor_SHEX {fhir:productOrService .}}
        TRANSLATED	DataRequirement.codeFilter	Either a path or a searchParam must be provided, but not both	path.exists() xor searchParam.exists()	{fhir:path . SHEX_Xor_SHEX {fhir:searchParam .}}
        TRANSLATED	DataRequirement.dateFilter	Either a path or a searchParam must be provided, but not both	path.exists() xor searchParam.exists()	{fhir:path . SHEX_Xor_SHEX {fhir:searchParam .}}
        TRANSLATED	DiagnosticReport	A resource referenced in a Composition entry must also be included in the DiagnosticReport result (Observation resources or nested resources via Observation.hasMember)	composition.exists() implies composition.resolve().section.entry.resolve().descendants().where((id in result.resolve().descendants().id).not()).empty()	{fhir:composition . SHEX_Implies_SHEX  NOT { fhir:composition.SHEX_resolve_SHEX (  ).section.entry.SHEX_resolve_SHEX (  ).SHEX_descendants_SHEX (  ).SHEX_where_SHEX ( NOT { .id SHEX_In_SHEX   SHEX_descendants_SHEX ( .result.SHEX_resolve_SHEX (  ) ).id }) {fhir:v .} } }
        TRANSLATED	Distance	There SHALL be a code if there is a value and it SHALL be an expression of length.  If system is present, it SHALL be UCUM.	(code.exists() or value.empty()) and (system.empty() or system = %ucum)	({fhir:code . OR  NOT { fhir:value {fhir:v .} } }) AND ( NOT { fhir:system {fhir:v .} }  OR ({ fhir:system { fhir:v ['http://unitsofmeasure.org'] }  }))
        TRANSLATED	DocumentReference	facilityType SHALL only be present if context is not an encounter	facilityType.empty() or context.where(resolve() is Encounter).empty()	 NOT { fhir:facilityType {fhir:v .} }  OR  NOT { fhir:context.SHEX_where_SHEX (  SHEX_resolve_SHEX (  ) a Encounter) {fhir:v .} } 
        TRANSLATED	DocumentReference	practiceSetting SHALL only be present if context is not present	practiceSetting.empty() or context.where(resolve() is Encounter).empty()	 NOT { fhir:practiceSetting {fhir:v .} }  OR  NOT { fhir:context.SHEX_where_SHEX (  SHEX_resolve_SHEX (  ) a Encounter) {fhir:v .} } 
        TRANSLATED	DomainResource	A resource should have narrative for robust management	text.`div`.exists()	{fhir:text.div .}
        TRANSLATED	DomainResource	If a resource is contained in another resource, it SHALL NOT have a meta.versionId or a meta.lastUpdated	contained.meta.versionId.empty() and contained.meta.lastUpdated.empty()	 NOT { fhir:contained.meta.versionId {fhir:v .} }  AND  NOT { fhir:contained.meta.lastUpdated {fhir:v .} } 
        TRANSLATED	DomainResource	If a resource is contained in another resource, it SHALL NOT have a security label	contained.meta.security.empty()	 NOT { fhir:contained.meta.security {fhir:v .} } 
        TRANSLATED	DomainResource	If the resource is contained in another resource, it SHALL NOT contain nested Resources	contained.contained.empty()	 NOT { fhir:contained.contained {fhir:v .} } 
        TRANSLATED	DomainResource	If the resource is contained in another resource, it SHALL be referred to from elsewhere in the resource or SHALL refer to the containing resource	contained.where((('#'+id in (%resource.descendants().reference | %resource.descendants().ofType(canonical) | %resource.descendants().ofType(uri) | %resource.descendants().ofType(url))) or descendants().where(reference = '#').exists() or descendants().where(as(canonical) = '#').exists() or descendants().where(as(canonical) = '#').exists()).not()).trace('unmatched', id).empty()	 NOT { fhir:contained.SHEX_where_SHEX ( NOT { .'#' SHEX_Plus_SHEX id { fhir:v [  SHEX_descendants_SHEX ( .'http://hl7.org/fhir/StructureDefinition/Resource' ).reference   SHEX_descendants_SHEX ( .'http://hl7.org/fhir/StructureDefinition/Resource' ). SHEX_ofType_SHEX (canonical)   SHEX_descendants_SHEX ( .'http://hl7.org/fhir/StructureDefinition/DomainResource' ). SHEX_ofType_SHEX (uri)   SHEX_descendants_SHEX ( .'id' ). SHEX_ofType_SHEX (url)] }  OR   SHEX_descendants_SHEX (  ). SHEX_where_SHEX (reference { fhir:v ['#'] } ) . OR   SHEX_descendants_SHEX (  ). SHEX_where_SHEX ( SHEX_as_SHEX (canonical) { fhir:v ['#'] } ) . OR   SHEX_descendants_SHEX (  ). SHEX_where_SHEX ( SHEX_as_SHEX (canonical) { fhir:v ['#'] } ) . }).SHEX_trace_SHEX ('unmatched', id) {fhir:v .} } 
        TRANSLATED	Dosage	AsNeededFor can only be set if AsNeeded is empty or true	asNeededFor.empty() or asNeeded.empty() or asNeeded	 NOT { fhir:asNeededFor {fhir:v .} }  OR  NOT { fhir:asNeeded {fhir:v .} }  OR { fhir:asNeeded }
        TRANSLATED	Duration	There SHALL be a code if there is a value and it SHALL be an expression of time.  If system is present, it SHALL be UCUM.	code.exists() implies ((system = %ucum) and value.exists())	{fhir:code . SHEX_Implies_SHEX (({ fhir:system { fhir:v ['http://unitsofmeasure.org'] }  }) AND {fhir:value .})}
        TRANSLATED	Element	All FHIR elements must have a @value or children	hasValue() or (children().count() > id.count())	 . OR (  SHEX_count_SHEX (   SHEX_children_SHEX (  ) ) SHEX_Greater_SHEX   SHEX_count_SHEX ( fhir:id ))
        TRANSLATED	Element.extension	All FHIR elements must have a @value or children	hasValue() or (children().count() > id.count())	 . OR (  SHEX_count_SHEX (   SHEX_children_SHEX (  ) ) SHEX_Greater_SHEX   SHEX_count_SHEX ( fhir:id ))
        TRANSLATED	Encounter.participant	A type cannot be provided for a patient or group participant	actor.exists(resolve() is Patient or resolve() is Group) implies type.exists().not()	  SHEX_resolve_SHEX ( fhir:actor ) a Patient OR   SHEX_resolve_SHEX (  ) a Group SHEX_Implies_SHEX  NOT { fhir:type. }
        TRANSLATED	Encounter.participant	A type must be provided when no explicit actor is specified	actor.exists() or type.exists()	{fhir:actor . OR {fhir:type .}}
        TRANSLATED	Evidence	Name should be usable as an identifier for the module by machine processing applications such as code generation	name.exists() implies name.matches('[A-Z]([A-Za-z0-9_]){1,254}')	{fhir:name . SHEX_Implies_SHEX {fhir:name { fhir:v /'[A-Z]([A-Za-z0-9_]){1,254}'/ } }}
        TRANSLATED	Evidence.url	URL should not contain | or # - these characters make processing canonical references problematic	url.matches('([^|#])*')	{fhir:url { fhir:v /'([^|#])*'/ } }
        TRANSLATED	EvidenceReport	Name should be usable as an identifier for the module by machine processing applications such as code generation	name.exists() implies name.matches('[A-Z]([A-Za-z0-9_]){1,254}')	{fhir:name . SHEX_Implies_SHEX {fhir:name { fhir:v /'[A-Z]([A-Za-z0-9_]){1,254}'/ } }}
        TRANSLATED	EvidenceReport.url	URL should not contain | or # - these characters make processing canonical references problematic	url.matches('([^|#])*')	{fhir:url { fhir:v /'([^|#])*'/ } }
        TRANSLATED	EvidenceVariable	Name should be usable as an identifier for the module by machine processing applications such as code generation	name.exists() implies name.matches('[A-Z]([A-Za-z0-9_]){1,254}')	{fhir:name . SHEX_Implies_SHEX {fhir:name { fhir:v /'[A-Z]([A-Za-z0-9_]){1,254}'/ } }}
        TRANSLATED	EvidenceVariable.characteristic	In a characteristic, at most one of these seven elements shall be used: definitionReference or definitionCanonical or definitionCodeableConcept or definitionExpression or definitionId or definitionByTypeAndValue or definitionByCombination	(definitionReference.count() + definitionCanonical.count() + definitionCodeableConcept.count() + definitionExpression.count() + definitionId.count() + definitionByTypeAndValue.count() + definitionByCombination.count())  < 2	(  SHEX_count_SHEX ( fhir:definitionReference ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:definitionCanonical ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:definitionCodeableConcept ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:definitionExpression ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:definitionId ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:definitionByTypeAndValue ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:definitionByCombination )) { fhir:v MaxExclusive 2 } 
        TRANSLATED	EvidenceVariable.url	URL should not contain | or # - these characters make processing canonical references problematic	url.matches('([^|#])*')	{fhir:url { fhir:v /'([^|#])*'/ } }
        TRANSLATED	ExampleScenario	Actor keys must be unique	actor.key.count() = actor.key.distinct().count()	  SHEX_count_SHEX ( fhir:actor.key ) SHEX_Equals_SHEX   SHEX_count_SHEX ( fhir:actor.key.SHEX_distinct_SHEX (  ) )
        TRANSLATED	ExampleScenario	Actor titles must be unique	actor.title.count() = actor.title.distinct().count()	  SHEX_count_SHEX ( fhir:actor.title ) SHEX_Equals_SHEX   SHEX_count_SHEX ( fhir:actor.title.SHEX_distinct_SHEX (  ) )
        TRANSLATED	ExampleScenario	Instance keys must be unique	instance.key.count() = instance.key.distinct().count()	  SHEX_count_SHEX ( fhir:instance.key ) SHEX_Equals_SHEX   SHEX_count_SHEX ( fhir:instance.key.SHEX_distinct_SHEX (  ) )
        TRANSLATED	ExampleScenario	Instance titles must be unique	instance.title.count() = instance.title.distinct().count()	  SHEX_count_SHEX ( fhir:instance.title ) SHEX_Equals_SHEX   SHEX_count_SHEX ( fhir:instance.title.SHEX_distinct_SHEX (  ) )
        TRANSLATED	ExampleScenario	Must have actors if status is active or required	status='active' or status='retired' implies actor.exists()	(({ fhir:status { fhir:v ['active'] }  }) OR ({ fhir:status { fhir:v ['retired'] }  })) SHEX_Implies_SHEX {fhir:actor .}
        TRANSLATED	ExampleScenario	Must have processes if status is active or required	status='active' or status='retired' implies process.exists()	(({ fhir:status { fhir:v ['active'] }  }) OR ({ fhir:status { fhir:v ['retired'] }  })) SHEX_Implies_SHEX {fhir:process .}
        TRANSLATED	ExampleScenario	Name should be usable as an identifier for the module by machine processing applications such as code generation	name.exists() implies name.matches('[A-Z]([A-Za-z0-9_]){1,254}')	{fhir:name . SHEX_Implies_SHEX {fhir:name { fhir:v /'[A-Z]([A-Za-z0-9_]){1,254}'/ } }}
        TRANSLATED	ExampleScenario	Process titles must be unique	process.title.count() = process.title.distinct().count()	  SHEX_count_SHEX ( fhir:process.title ) SHEX_Equals_SHEX   SHEX_count_SHEX ( fhir:process.title.SHEX_distinct_SHEX (  ) )
        TRANSLATED	ExampleScenario.actor	Actor should be referenced in at least one operation	%resource.process.descendants().select(operation).where(initiator=%context.key or receiver=%context.key).exists()	  SHEX_descendants_SHEX ( 'false'.process ). SHEX_select_SHEX (operation). SHEX_where_SHEX (initiator { fhir:v ['%context'.key] }  OR receiver { fhir:v ['%context'.key] } ) .
        TRANSLATED	ExampleScenario.actor	actor.key canot be 'OTHER'	key != 'OTHER'	{ fhir:key [fhir:v  . -'OTHER']  }
        TRANSLATED	ExampleScenario.instance	Instance should be referenced in at least one location	%resource.process.descendants().select(instanceReference).where($this=%context.key).exists()	  SHEX_descendants_SHEX ( 'false'.process ). SHEX_select_SHEX (instanceReference). SHEX_where_SHEX ($this { fhir:v ['%context'.key] } ) .
        TRANSLATED	ExampleScenario.instance	Instance version should be referenced in at least one operation	version.exists() implies version.key.intersect(%resource.process.descendants().where(instanceReference = %context.key).versionReference).exists()	{fhir:version . SHEX_Implies_SHEX  SHEX_intersect_SHEX (  SHEX_descendants_SHEX ( fhir:version.key.'%resource'.process ). SHEX_where_SHEX (instanceReference { fhir:v ['%context'.key] } ).versionReference) .}
        TRANSLATED	ExampleScenario.instance	StructureVersion is required if structureType is not FHIR (but may still be present even if FHIR)	structureType.exists() and structureType.memberOf('http://hl7.org/fhir/ValueSet/resource-types').not() implies structureVersion.exists()	({fhir:structureType . AND  NOT { fhir:structureType.SHEX_memberOf_SHEX ('http://hl7.org/fhir/ValueSet/resource-types') }}) SHEX_Implies_SHEX {fhir:structureVersion .}
        TRANSLATED	ExampleScenario.instance	Version keys must be unique within an instance	version.key.count() = version.key.distinct().count()	  SHEX_count_SHEX ( fhir:version.key ) SHEX_Equals_SHEX   SHEX_count_SHEX ( fhir:version.key.SHEX_distinct_SHEX (  ) )
        TRANSLATED	ExampleScenario.instance	Version titles must be unique within an instance	version.title.count() = version.title.distinct().count()	  SHEX_count_SHEX ( fhir:version.title ) SHEX_Equals_SHEX   SHEX_count_SHEX ( fhir:version.title.SHEX_distinct_SHEX (  ) )
        TRANSLATED	ExampleScenario.instance	instance.content is only allowed if there are no instance.versions	instance.content.exists() implies instance.version.empty()	{fhir:instance.content . SHEX_Implies_SHEX  NOT { fhir:instance.version {fhir:v .} } }
        TRANSLATED	ExampleScenario.instance.containedInstance	InstanceReference must be a key of an instance defined in the ExampleScenario	%resource.instance.where(key=%context.instanceReference).exists()	'false'.instance. SHEX_where_SHEX (key { fhir:v ['%context'.instanceReference] } ) .
        TRANSLATED	ExampleScenario.instance.containedInstance	versionReference must be a key of a version within the instance pointed to by instanceReference	versionReference.exists() implies %resource.instance.where(key=%context.instanceReference).version.where(key=%context.versionReference).exists()	{fhir:versionReference . SHEX_Implies_SHEX 'false'.instance. SHEX_where_SHEX (key { fhir:v ['%context'.instanceReference] } ).version. SHEX_where_SHEX (key { fhir:v ['%context'.versionReference] } ) .}
        TRANSLATED	ExampleScenario.instance.containedInstance	versionReference must be specified if the referenced instance defines versions	versionReference.empty() implies %resource.instance.where(key=%context.instanceReference).version.empty()	 NOT { fhir:versionReference {fhir:v .} }  SHEX_Implies_SHEX  NOT { 'true'.instance.SHEX_where_SHEX (key { fhir:v ['%context'.instanceReference] } ).version {fhir:v .} } 
        TRANSLATED	ExampleScenario.process	Processes must have steps if ExampleScenario status is active or required	%resource.status='active' or %resource.status='retired' implies step.exists()	'false'.status { fhir:v ['active'] }  OR 'false'.status { fhir:v ['retired'] }  SHEX_Implies_SHEX {fhir:step .}
        TRANSLATED	ExampleScenario.process.step	Alternative titles must be unique within a step	alternative.title.count() = alternative.title.distinct().count()	  SHEX_count_SHEX ( fhir:alternative.title ) SHEX_Equals_SHEX   SHEX_count_SHEX ( fhir:alternative.title.SHEX_distinct_SHEX (  ) )
        TRANSLATED	ExampleScenario.process.step	Can have a process, a workflow, one or more operations or none of these, but cannot have a combination	(process.exists() implies workflow.empty() and operation.empty()) and (workflow.exists() implies operation.empty())	({fhir:process . SHEX_Implies_SHEX ( NOT { fhir:workflow {fhir:v .} }  AND  NOT { fhir:operation {fhir:v .} } )}) AND ({fhir:workflow . SHEX_Implies_SHEX  NOT { fhir:operation {fhir:v .} } })
        TRANSLATED	ExampleScenario.process.step.operation	If specified, initiator must be a key of an actor within the ExampleScenario	initiator.exists() implies initator = 'OTHER' or %resource.actor.where(key=%context.initiator).exists()	{fhir:initiator . SHEX_Implies_SHEX (({ fhir:initator { fhir:v ['OTHER'] }  }) OR 'false'.actor. SHEX_where_SHEX (key { fhir:v ['%context'.initiator] } ) .)}
        TRANSLATED	ExampleScenario.process.step.operation	If specified, receiver must be a key of an actor within the ExampleScenario	receiver.exists() implies receiver = 'OTHER' or %resource.actor.where(key=%context.receiver).exists()	{fhir:receiver . SHEX_Implies_SHEX (({ fhir:receiver { fhir:v ['OTHER'] }  }) OR 'false'.actor. SHEX_where_SHEX (key { fhir:v ['%context'.receiver] } ) .)}
        TRANSLATED	ExampleScenario.url	URL should not contain | or # - these characters make processing canonical references problematic	url.matches('([^|#])*')	{fhir:url { fhir:v /'([^|#])*'/ } }
        TRANSLATED	Expression	An expression or a reference must be provided	expression.exists() or reference.exists()	{fhir:expression . OR {fhir:reference .}}
        TRANSLATED	Extension	Cannot be used where description already exists or description is of type string or markdown.	%resource.description.exists().not() or ((%resource.description is string).not() and (%resource.description is markdown).not())	 NOT { 'false'.description. } OR ( NOT { 'true'.description a { fhir:string } } AND  NOT { 'true'.description a { fhir:markdown } })
        TRANSLATED	Extension	Cannot be used where title already exists.	%resource.title.exists().not()	 NOT { 'false'.title. }
        TRANSLATED	Extension	Cannot have length if offset is missing.	extension.where(url='length').exists() implies extension.where(url='offset').exists()	{fhir:extension. SHEX_where_SHEX (url { fhir:v ['length'] } ) . SHEX_Implies_SHEX {fhir:extension. SHEX_where_SHEX (url { fhir:v ['offset'] } ) .}}
        TRANSLATED	Extension	If the substanceExposureRisk extension element is present, the AllergyIntolerance.code element must be omitted.	substanceExposureRisk.exists() and code.empty()	{fhir:substanceExposureRisk . AND  NOT { fhir:code {fhir:v .} } }
        TRANSLATED	Extension	Must have either extensions or value[x], not both	extension.exists() != value.exists()	{fhir:extension . SHEX_NotEquals_SHEX {fhir:value .}}
        TRANSLATED	Extension	Variable expressions must have a name	value.name.exists()	{fhir:value.name .}
        TRANSLATED	FamilyMemberHistory	Can have age[x] or born[x], but not both	age.empty() or born.empty()	 NOT { fhir:age {fhir:v .} }  OR  NOT { fhir:born {fhir:v .} } 
        TRANSLATED	FamilyMemberHistory	Can have age[x] or deceased[x], but not both	age.empty() or deceased.empty()	 NOT { fhir:age {fhir:v .} }  OR  NOT { fhir:deceased {fhir:v .} } 
        TRANSLATED	FamilyMemberHistory	Can only have estimatedAge if age[x] is present	age.exists() or estimatedAge.empty()	{fhir:age . OR  NOT { fhir:estimatedAge {fhir:v .} } }
        TRANSLATED	Goal.target	Goal.target.measure is required if Goal.target.detail is populated	(detail.exists() and measure.exists()) or detail.exists().not()	({fhir:detail . AND {fhir:measure .}}) OR  NOT { fhir:detail. }
        TRANSLATED	ImmunizationRecommendation.recommendation	One of vaccineCode or targetDisease SHALL be present	vaccineCode.exists() or targetDisease.exists()	{fhir:vaccineCode . OR {fhir:targetDisease .}}
        TRANSLATED	ImplementationGuide	If a resource has a fhirVersion, it must be one of the versions defined for the Implementation Guide	definition.resource.fhirVersion.all(%context.fhirVersion contains $this)	{fhir:definition.resource.fhirVersion. SHEX_all_SHEX ('%context'.fhirVersion SHEX_Contains_SHEX $this)}
        TRANSLATED	ImplementationGuide	Name should be usable as an identifier for the module by machine processing applications such as code generation	name.exists() implies name.matches('[A-Z]([A-Za-z0-9_]){1,254}')	{fhir:name . SHEX_Implies_SHEX {fhir:name { fhir:v /'[A-Z]([A-Za-z0-9_]){1,254}'/ } }}
        TRANSLATED	ImplementationGuide.definition	If a resource has a groupingId, it must refer to a grouping defined in the Implementation Guide	resource.groupingId.all(%context.grouping.id contains $this)	{fhir:resource.groupingId. SHEX_all_SHEX ('%context'.grouping.id SHEX_Contains_SHEX $this)}
        TRANSLATED	ImplementationGuide.definition.page	Source must be absent if 'generated' is generated	generation='generated' implies source.empty()	({ fhir:generation { fhir:v ['generated'] }  }) SHEX_Implies_SHEX  NOT { fhir:source {fhir:v .} } 
        TRANSLATED	ImplementationGuide.url	URL should not contain | or # - these characters make processing canonical references problematic	url.matches('([^|#])*')	{fhir:url { fhir:v /'([^|#])*'/ } }
        TRANSLATED	Ingredient	If an ingredient is noted as an allergen (allergenicIndicator) then its substance should be a code. If the substance is a SubstanceDefinition, then the allegen information should be documented in that resource	(Ingredient.allergenicIndicator.where(value='true').count() + Ingredient.substance.code.reference.count())  < 2	(  SHEX_count_SHEX ( fhir:Ingredient.allergenicIndicator.SHEX_where_SHEX (value { fhir:v ['true'] } ) ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:Ingredient.substance.code.reference )) { fhir:v MaxExclusive 2 } 
        TRANSLATED	InsurancePlan	The organization SHALL at least have a name or an identifier, and possibly more than one	(identifier.count() + name.count()) > 0	(  SHEX_count_SHEX ( fhir:identifier ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:name )) { fhir:v MinExclusive 0 } 
        TRANSLATED	Linkage	Must have at least two items	item.count()>1	  SHEX_count_SHEX ( fhir:item ) { fhir:v MinExclusive 1 } 
        TRANSLATED	List	A list can only have an emptyReason if it is empty	emptyReason.empty() or entry.empty()	 NOT { fhir:emptyReason {fhir:v .} }  OR  NOT { fhir:entry {fhir:v .} } 
        TRANSLATED	MedicationAdministration.dosage	If dosage attribute is present then SHALL have at least one of dosage.text or dosage.dose or dosage.rate[x]	(dose.exists() or rate.exists() or text.exists())	({fhir:dose . OR {fhir:rate . OR {fhir:text .}}})
        TRANSLATED	MedicationDispense	whenHandedOver cannot be before whenPrepared	whenHandedOver.empty() or whenPrepared.empty() or whenHandedOver >= whenPrepared	 NOT { fhir:whenHandedOver {fhir:v .} }  OR  NOT { fhir:whenPrepared {fhir:v .} }  OR ({ fhir:whenHandedOver SHEX_GreaterOrEqual_SHEX { fhir:whenPrepared } })
        TRANSLATED	MolecularSequence.relative.startingSequence	Both genomeAssembly and chromosome must be both contained if either one of them is contained	(chromosome.empty() and genomeAssembly.empty()) or (chromosome.exists() and genomeAssembly.exists())	( NOT { fhir:chromosome {fhir:v .} }  AND  NOT { fhir:genomeAssembly {fhir:v .} } ) OR ({fhir:chromosome . AND {fhir:genomeAssembly .}})
        TRANSLATED	MolecularSequence.relative.startingSequence	Have and only have one of the following elements in startingSequence: 1. genomeAssembly; 2 sequence	(genomeAssembly.count()+sequenceCodeableConcept.count()+ sequenceReference.count()+ sequenceString.count()) = 1	(  SHEX_count_SHEX ( fhir:genomeAssembly ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:sequenceCodeableConcept ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:sequenceReference ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:sequenceString )) { fhir:v [1] } 
        TRANSLATED	Narrative.div	The narrative SHALL contain only the basic html formatting elements and attributes described in chapters 7-11 (except section 4 of chapter 9) and 15 of the HTML 4.0 standard, <a> elements (either name or href), images and internally contained style attributes	htmlChecks()	  SHEX_htmlChecks_SHEX (  )
        TRANSLATED	Narrative.div	The narrative SHALL have some non-whitespace content	htmlChecks()	  SHEX_htmlChecks_SHEX (  )
        TRANSLATED	NutritionOrder	Nutrition Order SHALL contain either Oral Diet , Supplement, or Enteral Formula class	oralDiet.exists() or supplement.exists() or enteralFormula.exists()	{fhir:oralDiet . OR {fhir:supplement . OR {fhir:enteralFormula .}}}
        TRANSLATED	Observation	If Observation.code is the same as an Observation.component.code then the value element associated with the code SHALL NOT be present	value.empty() or component.code.where(coding.intersect(%resource.code.coding).exists()).empty()	 NOT { fhir:value {fhir:v .} }  OR  NOT { fhir:component.code.SHEX_where_SHEX (coding. SHEX_intersect_SHEX ('%resource'.code.coding) .) {fhir:v .} } 
        TRANSLATED	Observation	If there is no component or hasMember element then either a value[x] or a data absent reason must be present.	(component.empty() and hasMember.empty()) implies (dataAbsentReason.exists() or value.exists())	( NOT { fhir:component {fhir:v .} }  AND  NOT { fhir:hasMember {fhir:v .} } ) SHEX_Implies_SHEX ({fhir:dataAbsentReason . OR {fhir:value .}})
        TRANSLATED	Observation	dataAbsentReason SHALL only be present if Observation.value[x] is not present	dataAbsentReason.empty() or value.empty()	 NOT { fhir:dataAbsentReason {fhir:v .} }  OR  NOT { fhir:value {fhir:v .} } 
        TRANSLATED	Observation.bodyStructure	bodyStructure SHALL only be present if Observation.bodySite is not present	bodyStructure.empty() or bodySite.empty()	 NOT { fhir:bodyStructure {fhir:v .} }  OR  NOT { fhir:bodySite {fhir:v .} } 
        TRANSLATED	Observation.component	If there is no a value a data absent reason must be present	value.exists() or dataAbsentReason.exists()	{fhir:value . OR {fhir:dataAbsentReason .}}
        TRANSLATED	Observation.referenceRange	Must have at least a low or a high or text	low.exists() or high.exists() or text.exists()	{fhir:low . OR {fhir:high . OR {fhir:text .}}}
        TRANSLATED	Observation.specimen	If Observation.specimen is a reference to Group, the group can only have specimens	reference = 'Group' implies member.entity.resolve() is Specimen	({ fhir:reference { fhir:v ['Group'] }  }) SHEX_Implies_SHEX (  SHEX_resolve_SHEX ( fhir:member.entity ) a { fhir:Specimen })
        TRANSLATED	Organization	The organization SHALL at least have a name or an identifier, and possibly more than one	(identifier.count() + name.count()) > 0	(  SHEX_count_SHEX ( fhir:identifier ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:name )) { fhir:v MinExclusive 0 } 
        TRANSLATED	Organization.contact	The address of an organization can never be of use 'home'	address.where(use = 'home').empty()	 NOT { fhir:address.SHEX_where_SHEX (use { fhir:v ['home'] } ) {fhir:v .} } 
        TRANSLATED	Organization.contact	The telecom of an organization can never be of use 'home'	telecom.where(use = 'home').empty()	 NOT { fhir:telecom.SHEX_where_SHEX (use { fhir:v ['home'] } ) {fhir:v .} } 
        TRANSLATED	OrganizationAffiliation.contact	The address of an organization can never be of use 'home'	address.where(use = 'home').empty()	 NOT { fhir:address.SHEX_where_SHEX (use { fhir:v ['home'] } ) {fhir:v .} } 
        TRANSLATED	OrganizationAffiliation.contact	The telecom of an organization can never be of use 'home'	telecom.where(use = 'home').empty()	 NOT { fhir:telecom.SHEX_where_SHEX (use { fhir:v ['home'] } ) {fhir:v .} } 
        TRANSLATED	Parameters.parameter	A parameter must have one and only one of (value, resource, part)	(part.exists() and value.empty() and resource.empty()) or (part.empty() and (value.exists() xor resource.exists()))	({fhir:part . AND  NOT { fhir:value {fhir:v .} }  AND  NOT { fhir:resource {fhir:v .} } }) OR ( NOT { fhir:part {fhir:v .} }  AND ({fhir:value . SHEX_Xor_SHEX {fhir:resource .}}))
        TRANSLATED	Patient.contact	SHALL at least contain a contact's details or a reference to an organization	name.exists() or telecom.exists() or address.exists() or organization.exists()	{fhir:name . OR {fhir:telecom . OR {fhir:address . OR {fhir:organization .}}}}
        TRANSLATED	Period	If present, start SHALL have a lower or equal value than end	start.hasValue().not() or end.hasValue().not() or (start <= end)	 NOT { fhir:start. } OR  NOT { fhir:end. } OR ({ fhir:start SHEX_LessOrEqual_SHEX { fhir:end } })
        TRANSLATED	Provenance.agent	If who is a PractitionerRole, onBehalfOf can't reference the same Practitioner	who.resolve().ofType(PractitionerRole).practitioner.resolve().exists() and onBehalfOf.resolve().ofType(Practitioner).exists() implies who.resolve().practitioner.resolve() != onBehalfOf.resolve()	(  SHEX_resolve_SHEX ( fhir:who.SHEX_resolve_SHEX (  ).SHEX_ofType_SHEX (PractitionerRole).practitioner ) . AND   SHEX_resolve_SHEX ( fhir:onBehalfOf ). SHEX_ofType_SHEX (Practitioner) .) SHEX_Implies_SHEX (  SHEX_resolve_SHEX ( fhir:who.SHEX_resolve_SHEX (  ).practitioner ) SHEX_NotEquals_SHEX   SHEX_resolve_SHEX ( fhir:onBehalfOf ))
        TRANSLATED	Provenance.agent	If who is an organization, onBehalfOf can't be a PractitionerRole within that organization	who.resolve().ofType(Organization).exists() and onBehalfOf.resolve().ofType(PractitionerRole).organization.resolve().exists() implies who.resolve() != onBehalfOf.resolve().organization.resolve()	(  SHEX_resolve_SHEX ( fhir:who ). SHEX_ofType_SHEX (Organization) . AND   SHEX_resolve_SHEX ( fhir:onBehalfOf.SHEX_resolve_SHEX (  ).SHEX_ofType_SHEX (PractitionerRole).organization ) .) SHEX_Implies_SHEX (  SHEX_resolve_SHEX ( fhir:who ) SHEX_NotEquals_SHEX   SHEX_resolve_SHEX ( fhir:onBehalfOf.SHEX_resolve_SHEX (  ).organization ))
        TRANSLATED	Provenance.agent	Who and onBehalfOf cannot be the same	who.resolve().exists() and onBehalfOf.resolve().exists() implies who.resolve() != onBehalfOf.resolve()	(  SHEX_resolve_SHEX ( fhir:who ) . AND   SHEX_resolve_SHEX ( fhir:onBehalfOf ) .) SHEX_Implies_SHEX (  SHEX_resolve_SHEX ( fhir:who ) SHEX_NotEquals_SHEX   SHEX_resolve_SHEX ( fhir:onBehalfOf ))
        TRANSLATED	Quantity	If a code for the unit is present, the system SHALL also be present	code.empty() or system.exists()	 NOT { fhir:code {fhir:v .} }  OR {fhir:system .}
        TRANSLATED	Quantity	The comparator is not used on a SimpleQuantity	comparator.empty()	 NOT { fhir:comparator {fhir:v .} } 
        TRANSLATED	Quantity	There SHALL be a code if there is a value and it SHALL be an expression of currency.  If system is present, it SHALL be ISO 4217 (system = "urn:iso:std:iso:4217" - currency).	(code.exists() or value.empty()) and (system.empty() or system = 'urn:iso:std:iso:4217')	({fhir:code . OR  NOT { fhir:value {fhir:v .} } }) AND ( NOT { fhir:system {fhir:v .} }  OR ({ fhir:system { fhir:v ['urn:iso:std:iso:4217'] }  }))
        TRANSLATED	Questionnaire	Name should be usable as an identifier for the module by machine processing applications such as code generation	name.exists() implies name.matches('[A-Z]([A-Za-z0-9_]){1,254}')	{fhir:name . SHEX_Implies_SHEX {fhir:name { fhir:v /'[A-Z]([A-Za-z0-9_]){1,254}'/ } }}
        TRANSLATED	Questionnaire	The link ids for groups and questions must be unique within the questionnaire	descendants().linkId.isDistinct()	  SHEX_isDistinct_SHEX (   SHEX_descendants_SHEX (  ).linkId )
        TRANSLATED	Questionnaire.item	A question cannot have both answerOption and answerValueSet	answerOption.empty() or answerValueSet.empty()	 NOT { fhir:answerOption {fhir:v .} }  OR  NOT { fhir:answerValueSet {fhir:v .} } 
        TRANSLATED	Questionnaire.item	Can only have answerConstraint if answerOption or answerValueset are present.  (This is a warning because extensions may serve the same purpose)	answerConstraint.exists() implies answerOption.exists() or answerValueset.exists()	{fhir:answerConstraint . SHEX_Implies_SHEX ({fhir:answerOption . OR {fhir:answerValueset .}})}
        TRANSLATED	Questionnaire.item	Can only have multiple initial values for repeating items	repeats=true or initial.count() <= 1	({ fhir:repeats { fhir:v [true] }  }) OR (  SHEX_count_SHEX ( fhir:initial ) { fhir:v MaxInclusive 1 } )
        TRANSLATED	Questionnaire.item	Display items cannot have a "code" asserted	type!='display' or code.empty()	({ fhir:type [fhir:v  . -'display']  }) OR  NOT { fhir:code {fhir:v .} } 
        TRANSLATED	Questionnaire.item	Display items cannot have child items	type='display' implies item.empty()	({ fhir:type { fhir:v ['display'] }  }) SHEX_Implies_SHEX  NOT { fhir:item {fhir:v .} } 
        TRANSLATED	Questionnaire.item	Group items must have nested items when Questionanire is complete	(type='group' and %resource.status='complete') implies item.empty().not()	(({ fhir:type { fhir:v ['group'] }  }) AND 'false'.status { fhir:v ['complete'] } ) SHEX_Implies_SHEX  NOT { fhir:item.NOT {  {fhir:v .} } }
        TRANSLATED	Questionnaire.item	Groups should have items	type='group' implies item.empty().not()	({ fhir:type { fhir:v ['group'] }  }) SHEX_Implies_SHEX  NOT { fhir:item.NOT {  {fhir:v .} } }
        TRANSLATED	Questionnaire.item	If one or more answerOption is present, initial cannot be present.  Use answerOption.initialSelected instead	answerOption.empty() or initial.empty()	 NOT { fhir:answerOption {fhir:v .} }  OR  NOT { fhir:initial {fhir:v .} } 
        TRANSLATED	Questionnaire.item	If there are more than one enableWhen, enableBehavior must be specified	enableWhen.count() > 1 implies enableBehavior.exists()	(  SHEX_count_SHEX ( fhir:enableWhen ) { fhir:v MinExclusive 1 } ) SHEX_Implies_SHEX {fhir:enableBehavior .}
        TRANSLATED	Questionnaire.item	Initial values can't be specified for groups or display items	(type!='group' and type!='display') or initial.empty()	(({ fhir:type [fhir:v  . -'group']  }) AND ({ fhir:type [fhir:v  . -'display']  })) OR  NOT { fhir:initial {fhir:v .} } 
        TRANSLATED	Questionnaire.item	Maximum length can only be declared for simple question types	(type in ('boolean' | 'decimal' | 'integer' | 'string' | 'text' | 'url')) or answerConstraint='optionOrString' or maxLength.empty()	({ fhir:type { fhir:v ['boolean' 'decimal' 'integer' 'string' 'text' 'url'] }  }) OR ({ fhir:answerConstraint { fhir:v ['optionOrString'] }  }) OR  NOT { fhir:maxLength {fhir:v .} } 
        TRANSLATED	Questionnaire.item	Only coding, decimal, integer, date, dateTime, time, string or quantity  items can have answerOption or answerValueSet	(type='coding' or type = 'decimal' or type = 'integer' or type = 'date' or type = 'dateTime' or type = 'time' or type = 'string' or type = 'quantity') or (answerValueSet.empty() and answerOption.empty())	(({ fhir:type { fhir:v ['coding'] }  }) OR ({ fhir:type { fhir:v ['decimal'] }  }) OR ({ fhir:type { fhir:v ['integer'] }  }) OR ({ fhir:type { fhir:v ['date'] }  }) OR ({ fhir:type { fhir:v ['dateTime'] }  }) OR ({ fhir:type { fhir:v ['time'] }  }) OR ({ fhir:type { fhir:v ['string'] }  }) OR ({ fhir:type { fhir:v ['quantity'] }  })) OR ( NOT { fhir:answerValueSet {fhir:v .} }  AND  NOT { fhir:answerOption {fhir:v .} } )
        TRANSLATED	Questionnaire.item	Read-only can't be specified for "display" items	type!='display' or readOnly.empty()	({ fhir:type [fhir:v  . -'display']  }) OR  NOT { fhir:readOnly {fhir:v .} } 
        TRANSLATED	Questionnaire.item	Required and repeat aren't permitted for display items	type!='display' or (required.empty() and repeats.empty())	({ fhir:type [fhir:v  . -'display']  }) OR ( NOT { fhir:required {fhir:v .} }  AND  NOT { fhir:repeats {fhir:v .} } )
        TRANSLATED	Questionnaire.item.enableWhen	If the operator is 'exists', the value must be a boolean	operator = 'exists' implies (answer is Boolean)	({ fhir:operator { fhir:v ['exists'] }  }) SHEX_Implies_SHEX ({ fhir:answer a { fhir:Boolean } })
        TRANSLATED	Questionnaire.item.linkId	Link ids should be 255 characters or less	$this.length <= 255	{fhir:$this.length { fhir:v MaxInclusive 255 } }
        TRANSLATED	Questionnaire.url	URL should not contain | or # - these characters make processing canonical references problematic	url.matches('([^|#])*')	{fhir:url { fhir:v /'([^|#])*'/ } }
        TRANSLATED	QuestionnaireResponse.item	Item cannot contain both item and answer	(answer.exists() and item.exists()).not()	 NOT { {fhir:answer . AND {fhir:item .}} }
        TRANSLATED	QuestionnaireResponse.item	Repeated answers are combined in the answers array of a single item	repeat(answer|item).select(item.where(answer.value.exists()).linkId.isDistinct()).allTrue()	  SHEX_allTrue_SHEX (  SHEX_repeat_SHEX ({ fhir:answer { fhir:item } }).SHEX_select_SHEX (  SHEX_isDistinct_SHEX ( .item.SHEX_where_SHEX (answer.value .).linkId )) )
        TRANSLATED	Range	If present, low SHALL have a lower value than high	low.value.empty() or high.value.empty() or (low <= high)	 NOT { fhir:low.value {fhir:v .} }  OR  NOT { fhir:high.value {fhir:v .} }  OR ({ fhir:low SHEX_LessOrEqual_SHEX { fhir:high } })
        TRANSLATED	Ratio	Numerator and denominator SHALL both be present, or both are absent. If both are absent, there SHALL be some extension present	(numerator.empty() xor denominator.exists()) and (numerator.exists() or extension.exists())	( NOT { fhir:numerator {fhir:v .} }  SHEX_Xor_SHEX {fhir:denominator .}) AND ({fhir:numerator . OR {fhir:extension .}})
        TRANSLATED	RatioRange	If present, lowNumerator SHALL have a lower value than highNumerator	lowNumerator.empty() or highNumerator.empty() or (lowNumerator <= highNumerator)	 NOT { fhir:lowNumerator {fhir:v .} }  OR  NOT { fhir:highNumerator {fhir:v .} }  OR ({ fhir:lowNumerator SHEX_LessOrEqual_SHEX { fhir:highNumerator } })
        TRANSLATED	RatioRange	One of lowNumerator or highNumerator and denominator SHALL be present, or all are absent. If all are absent, there SHALL be some extension present	((lowNumerator.empty() and highNumerator.empty()) xor denominator.exists()) and (lowNumerator.exists() or extension.exists())	(( NOT { fhir:lowNumerator {fhir:v .} }  AND  NOT { fhir:highNumerator {fhir:v .} } ) SHEX_Xor_SHEX {fhir:denominator .}) AND ({fhir:lowNumerator . OR {fhir:extension .}})
        TRANSLATED	Reference	At least one of reference, identifier and display SHALL be present (unless an extension is provided).	reference.exists() or identifier.exists() or display.exists() or extension.exists()	{fhir:reference . OR {fhir:identifier . OR {fhir:display . OR {fhir:extension .}}}}
        TRANSLATED	Reference	SHALL have a contained resource if a local reference is provided	reference.exists()  implies (reference.startsWith('#').not() or (reference.substring(1).trace('url') in %rootResource.contained.id.trace('ids')) or (reference='#' and %rootResource!=%resource))	{fhir:reference . SHEX_Implies_SHEX ( NOT { fhir:reference.SHEX_startsWith_SHEX ('#') } OR ({fhir:reference. SHEX_substring_SHEX (1). SHEX_trace_SHEX ('url') { fhir:v ['%rootResource'.contained.id. SHEX_trace_SHEX ('ids')] } }) OR (({ fhir:reference { fhir:v ['#'] }  }) AND 'false' [fhir:v  . -'null'] ))}
        TRANSLATED	RequestOrchestration.action	Must have resource or action but not both	resource.exists() != action.exists()	{fhir:resource . SHEX_NotEquals_SHEX {fhir:action .}}
        TRANSLATED	RequestOrchestration.action.input	Input data elements must have a requirement or a relatedData, but not both	requirement.exists() xor relatedData.exists()	{fhir:requirement . SHEX_Xor_SHEX {fhir:relatedData .}}
        TRANSLATED	RequestOrchestration.action.output	Output data element must have a requirement or a relatedData, but not both	requirement.exists() xor relatedData.exists()	{fhir:requirement . SHEX_Xor_SHEX {fhir:relatedData .}}
        TRANSLATED	Requirements	Name should be usable as an identifier for the module by machine processing applications such as code generation	name.exists() implies name.matches('[A-Z]([A-Za-z0-9_]){1,254}')	{fhir:name . SHEX_Implies_SHEX {fhir:name { fhir:v /'[A-Z]([A-Za-z0-9_]){1,254}'/ } }}
        TRANSLATED	Requirements.url	URL should not contain | or # - these characters make processing canonical references problematic	url.matches('([^|#])*')	{fhir:url { fhir:v /'([^|#])*'/ } }
        TRANSLATED	RiskAssessment.prediction	Must be <= 100	probability is decimal implies (probability as decimal) <= 100	({ fhir:probability a { fhir:decimal } }) SHEX_Implies_SHEX (({ fhir:probability a { fhir:decimal } }) { fhir:v MaxInclusive 100 } )
        TRANSLATED	RiskAssessment.prediction.probability[x]	low and high must be percentages, if present	(low.empty() or ((low.code = '%') and (low.system = %ucum))) and (high.empty() or ((high.code = '%') and (high.system = %ucum)))	( NOT { fhir:low {fhir:v .} }  OR (({fhir:low.code { fhir:v ['%'] } }) AND ({fhir:low.system { fhir:v ['http://unitsofmeasure.org'] } }))) AND ( NOT { fhir:high {fhir:v .} }  OR (({fhir:high.code { fhir:v ['%'] } }) AND ({fhir:high.system { fhir:v ['http://unitsofmeasure.org'] } })))
        TRANSLATED	ServiceRequest	orderDetail SHALL only be present if code is present	orderDetail.empty() or code.exists()	 NOT { fhir:orderDetail {fhir:v .} }  OR {fhir:code .}
        TRANSLATED	ServiceRequest.bodyStructure	bodyStructure SHALL only be present if bodySite is not present	bodySite.exists() or bodyStructure.exists()	{fhir:bodySite . OR {fhir:bodyStructure .}}
        TRANSLATED	StructureMap	Name should be usable as an identifier for the module by machine processing applications such as code generation	name.exists() implies name.matches('[A-Z]([A-Za-z0-9_]){1,254}')	{fhir:name . SHEX_Implies_SHEX {fhir:name { fhir:v /'[A-Z]([A-Za-z0-9_]){1,254}'/ } }}
        TRANSLATED	StructureMap.group.rule.target	Can only have an element if you have a context	element.exists() implies context.exists()	{fhir:element . SHEX_Implies_SHEX {fhir:context .}}
        TRANSLATED	StructureMap.url	URL should not contain | or # - these characters make processing canonical references problematic	url.matches('([^|#])*')	{fhir:url { fhir:v /'([^|#])*'/ } }
        TRANSLATED	SubscriptionStatus	events listed in event notifications	type = 'event-notification' implies (notificationEvent.exists() and notificationEvent.first().exists())	({ fhir:type { fhir:v ['event-notification'] }  }) SHEX_Implies_SHEX ({fhir:notificationEvent . AND   SHEX_first_SHEX ( fhir:notificationEvent ) .})
        TRANSLATED	TestReport.setup.action	Setup action SHALL contain either an operation or assert but not both.	operation.exists() xor assert.exists()	{fhir:operation . SHEX_Xor_SHEX {fhir:assert .}}
        TRANSLATED	TestReport.test.action	Test action SHALL contain either an operation or assert but not both.	operation.exists() xor assert.exists()	{fhir:operation . SHEX_Xor_SHEX {fhir:assert .}}
        TRANSLATED	TestScript	Name should be usable as an identifier for the module by machine processing applications such as code generation	name.exists() implies name.matches('[A-Z]([A-Za-z0-9_]){1,254}')	{fhir:name . SHEX_Implies_SHEX {fhir:name { fhir:v /'[A-Z]([A-Za-z0-9_]){1,254}'/ } }}
        TRANSLATED	TestScript.metadata	TestScript metadata capability SHALL contain required or validated or both.	capability.required.exists() or capability.validated.exists()	{fhir:capability.required . OR {fhir:capability.validated .}}
        TRANSLATED	TestScript.setup.action	Setup action SHALL contain either an operation or assert but not both.	operation.exists() xor assert.exists()	{fhir:operation . SHEX_Xor_SHEX {fhir:assert .}}
        TRANSLATED	TestScript.setup.action.assert	Only a single assertion SHALL be present within setup action assert element.	extension.exists() or (contentType.count() + expression.count() + headerField.count() + minimumId.count() + navigationLinks.count() + path.count() + requestMethod.count() + resource.count() + responseCode.count() + response.count() + validateProfileId.count() <=1) or (((expression.count() + minimumId.count() <=2) or (expression.count() + validateProfileId.count() <=2)) and (expression.count() + path.count() <=1) and (minimumId.count() + validateProfileId.count() <=1)) or (((path.count() + minimumId.count() <=2) or (path.count() + validateProfileId.count() <=2)) and (expression.count() + path.count() <=1) and (minimumId.count() + validateProfileId.count() <=1))	{fhir:extension . OR ((  SHEX_count_SHEX ( fhir:contentType ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:expression ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:headerField ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:minimumId ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:navigationLinks ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:path ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:requestMethod ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:resource ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:responseCode ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:response ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:validateProfileId )) { fhir:v MaxInclusive 1 } ) OR ((((  SHEX_count_SHEX ( fhir:expression ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:minimumId )) { fhir:v MaxInclusive 2 } ) OR ((  SHEX_count_SHEX ( fhir:expression ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:validateProfileId )) { fhir:v MaxInclusive 2 } )) AND ((  SHEX_count_SHEX ( fhir:expression ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:path )) { fhir:v MaxInclusive 1 } ) AND ((  SHEX_count_SHEX ( fhir:minimumId ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:validateProfileId )) { fhir:v MaxInclusive 1 } )) OR ((((  SHEX_count_SHEX ( fhir:path ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:minimumId )) { fhir:v MaxInclusive 2 } ) OR ((  SHEX_count_SHEX ( fhir:path ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:validateProfileId )) { fhir:v MaxInclusive 2 } )) AND ((  SHEX_count_SHEX ( fhir:expression ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:path )) { fhir:v MaxInclusive 1 } ) AND ((  SHEX_count_SHEX ( fhir:minimumId ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:validateProfileId )) { fhir:v MaxInclusive 1 } ))}
        TRANSLATED	TestScript.setup.action.assert	Setup action assert SHALL contain either compareToSourceId and compareToSourceExpression, compareToSourceId and compareToSourcePath or neither.	compareToSourceId.empty() xor (compareToSourceExpression.exists() or compareToSourcePath.exists())	 NOT { fhir:compareToSourceId {fhir:v .} }  SHEX_Xor_SHEX ({fhir:compareToSourceExpression . OR {fhir:compareToSourcePath .}})
        TRANSLATED	TestScript.setup.action.assert	Setup action assert response and responseCode SHALL be empty when direction equals request	(response.empty() and responseCode.empty() and direction = 'request') or direction.empty() or direction = 'response'	( NOT { fhir:response {fhir:v .} }  AND  NOT { fhir:responseCode {fhir:v .} }  AND ({ fhir:direction { fhir:v ['request'] }  })) OR  NOT { fhir:direction {fhir:v .} }  OR ({ fhir:direction { fhir:v ['response'] }  })
        TRANSLATED	TestScript.setup.action.operation	Setup operation SHALL contain either sourceId or targetId or params or url.	sourceId.exists() or (targetId.count() + url.count() + params.count() = 1) or (type.code in ('capabilities' |'search' | 'transaction' | 'history'))	{fhir:sourceId . OR ((  SHEX_count_SHEX ( fhir:targetId ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:url ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:params )) { fhir:v [1] } ) OR ({fhir:type.code { fhir:v ['capabilities' 'search' 'transaction' 'history'] } })}
        TRANSLATED	TestScript.teardown.action.operation	Teardown operation SHALL contain either sourceId or targetId or params or url.	sourceId.exists() or (targetId.count() + url.count() + params.count() = 1) or (type.code in ('capabilities' | 'search' | 'transaction' | 'history'))	{fhir:sourceId . OR ((  SHEX_count_SHEX ( fhir:targetId ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:url ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:params )) { fhir:v [1] } ) OR ({fhir:type.code { fhir:v ['capabilities' 'search' 'transaction' 'history'] } })}
        TRANSLATED	TestScript.test.action	Test action SHALL contain either an operation or assert but not both.	operation.exists() xor assert.exists()	{fhir:operation . SHEX_Xor_SHEX {fhir:assert .}}
        TRANSLATED	TestScript.test.action.assert	Only a single assertion SHALL be present within test action assert element.	extension.exists() or (contentType.count() + expression.count() + headerField.count() + minimumId.count() + navigationLinks.count() + path.count() + requestMethod.count() + resource.count() + responseCode.count() + response.count() + validateProfileId.count() <=1) or (((expression.count() + minimumId.count() <=2) or (expression.count() + validateProfileId.count() <=2)) and (expression.count() + path.count() <=1) and (minimumId.count() + validateProfileId.count() <=1)) or (((path.count() + minimumId.count() <=2) or (path.count() + validateProfileId.count() <=2)) and (expression.count() + path.count() <=1) and (minimumId.count() + validateProfileId.count() <=1))	{fhir:extension . OR ((  SHEX_count_SHEX ( fhir:contentType ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:expression ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:headerField ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:minimumId ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:navigationLinks ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:path ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:requestMethod ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:resource ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:responseCode ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:response ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:validateProfileId )) { fhir:v MaxInclusive 1 } ) OR ((((  SHEX_count_SHEX ( fhir:expression ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:minimumId )) { fhir:v MaxInclusive 2 } ) OR ((  SHEX_count_SHEX ( fhir:expression ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:validateProfileId )) { fhir:v MaxInclusive 2 } )) AND ((  SHEX_count_SHEX ( fhir:expression ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:path )) { fhir:v MaxInclusive 1 } ) AND ((  SHEX_count_SHEX ( fhir:minimumId ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:validateProfileId )) { fhir:v MaxInclusive 1 } )) OR ((((  SHEX_count_SHEX ( fhir:path ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:minimumId )) { fhir:v MaxInclusive 2 } ) OR ((  SHEX_count_SHEX ( fhir:path ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:validateProfileId )) { fhir:v MaxInclusive 2 } )) AND ((  SHEX_count_SHEX ( fhir:expression ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:path )) { fhir:v MaxInclusive 1 } ) AND ((  SHEX_count_SHEX ( fhir:minimumId ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:validateProfileId )) { fhir:v MaxInclusive 1 } ))}
        TRANSLATED	TestScript.test.action.assert	Test action assert SHALL contain either compareToSourceId and compareToSourceExpression, compareToSourceId and compareToSourcePath or neither.	compareToSourceId.empty() xor (compareToSourceExpression.exists() or compareToSourcePath.exists())	 NOT { fhir:compareToSourceId {fhir:v .} }  SHEX_Xor_SHEX ({fhir:compareToSourceExpression . OR {fhir:compareToSourcePath .}})
        TRANSLATED	TestScript.test.action.assert	Test action assert response and response and responseCode SHALL be empty when direction equals request	(response.empty() and responseCode.empty() and direction = 'request') or direction.empty() or direction = 'response'	( NOT { fhir:response {fhir:v .} }  AND  NOT { fhir:responseCode {fhir:v .} }  AND ({ fhir:direction { fhir:v ['request'] }  })) OR  NOT { fhir:direction {fhir:v .} }  OR ({ fhir:direction { fhir:v ['response'] }  })
        TRANSLATED	TestScript.test.action.operation	Test operation SHALL contain either sourceId or targetId or params or url.	sourceId.exists() or (targetId.count() + url.count() + params.count() = 1) or (type.code in ('capabilities' | 'search' | 'transaction' | 'history'))	{fhir:sourceId . OR ((  SHEX_count_SHEX ( fhir:targetId ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:url ) SHEX_Plus_SHEX   SHEX_count_SHEX ( fhir:params )) { fhir:v [1] } ) OR ({fhir:type.code { fhir:v ['capabilities' 'search' 'transaction' 'history'] } })}
        TRANSLATED	TestScript.url	URL should not contain | or # - these characters make processing canonical references problematic	url.matches('([^|#])*')	{fhir:url { fhir:v /'([^|#])*'/ } }
        TRANSLATED	TestScript.variable	Variable can only contain one of expression, headerField or path.	expression.empty() or headerField.empty() or path.empty()	 NOT { fhir:expression {fhir:v .} }  OR  NOT { fhir:headerField {fhir:v .} }  OR  NOT { fhir:path {fhir:v .} } 
        TRANSLATED	Timing.repeat	If there's a countMax, there must be a count	countMax.empty() or count.exists()	 NOT { fhir:countMax {fhir:v .} }  OR {fhir:count .}
        TRANSLATED	Timing.repeat	If there's a durationMax, there must be a duration	durationMax.empty() or duration.exists()	 NOT { fhir:durationMax {fhir:v .} }  OR {fhir:duration .}
        TRANSLATED	Timing.repeat	If there's a periodMax, there must be a period	periodMax.empty() or period.exists()	 NOT { fhir:periodMax {fhir:v .} }  OR {fhir:period .}
        TRANSLATED	Timing.repeat	If there's a timeOfDay, there cannot be a when, or vice versa	timeOfDay.empty() or when.empty()	 NOT { fhir:timeOfDay {fhir:v .} }  OR  NOT { fhir:when {fhir:v .} } 
        TRANSLATED	Timing.repeat	If there's an offset, there must be a when (and not C, CM, CD, CV)	offset.empty() or (when.exists() and when.select($this in ('C' | 'CM' | 'CD' | 'CV')).allFalse())	 NOT { fhir:offset {fhir:v .} }  OR ({fhir:when . AND   SHEX_allFalse_SHEX ( fhir:when.SHEX_select_SHEX ($this { fhir:v ['C' 'CM' 'CD' 'CV'] } ) )})
        TRANSLATED	Timing.repeat	duration SHALL be a non-negative value	duration.exists() implies duration >= 0	{fhir:duration . SHEX_Implies_SHEX ({ fhir:duration { fhir:v MinInclusive 0 }  })}
        TRANSLATED	Timing.repeat	if there's a duration, there needs to be duration units	duration.empty() or durationUnit.exists()	 NOT { fhir:duration {fhir:v .} }  OR {fhir:durationUnit .}
        TRANSLATED	Timing.repeat	if there's a period, there needs to be period units	period.empty() or periodUnit.exists()	 NOT { fhir:period {fhir:v .} }  OR {fhir:periodUnit .}
        TRANSLATED	Timing.repeat	period SHALL be a non-negative value	period.exists() implies period >= 0	{fhir:period . SHEX_Implies_SHEX ({ fhir:period { fhir:v MinInclusive 0 }  })}
        TRANSLATED	ValueSet	Only one of rulesText, expression, or a compose definition SHALL be provided	extension('http://hl7.org/fhir/StructureDefinition/valueset-rules-text').exists() xor extension('http://hl7.org/fhir/StructureDefinition/valueset-expression').exists() xor compose.exists()	 SHEX_extension_SHEX ('http://hl7.org/fhir/StructureDefinition/valueset-rules-text') . SHEX_Xor_SHEX  SHEX_extension_SHEX ('http://hl7.org/fhir/StructureDefinition/valueset-expression') . SHEX_Xor_SHEX {fhir:compose .}
        TRANSLATED	ValueSet.expansion	For contains, a version SHALL be provided unless the parameters element has a "system-version" parameter corresponding to the system of the entry and the version matches the system-version parameter.	contains.version.exists() xor  parameter.where(name = 'system-version').exists()	{fhir:contains.version . SHEX_Xor_SHEX {fhir:parameter. SHEX_where_SHEX (name { fhir:v ['system-version'] } ) .}}
